image: docker:24.0.2

services:
  - name: docker:24.0.2-dind
    alias: docker

variables:
  DOCKER_HOST: "tcp://docker:2375/"
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2

stages:
  - test

before_script:
  # ensure docker daemon reachable
  - until docker info >/dev/null 2>&1; do sleep 1; done
  # install prerequisites (Alpine)
  - apk add --no-cache curl bash jq ca-certificates
  # install Docker Compose V2 as docker CLI plugin
  - mkdir -p /usr/local/lib/docker/cli-plugins
  - 'curl -SL "https://github.com/docker/compose/releases/download/v2.24.2/docker-compose-linux-$(uname -m)" -o /usr/local/lib/docker/cli-plugins/docker-compose'
  - chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
  - docker compose version
  - docker info

integration_tests:
  stage: test
  script:
    - cp .env.default .env
    - docker compose build --parallel
    - docker compose up -d
    - echo "Waiting for containers to start..."
    - |
      # wait for mysql to respond
      MYSQL_C=""
      for i in $(seq 1 30); do
        MYSQL_C=$(docker compose ps -q mysql) || true
        if [ -n "$MYSQL_C" ]; then
          if docker exec "$MYSQL_C" mysqladmin ping -ppassword >/dev/null 2>&1; then
            echo "MySQL ready"; break
          fi
        fi
        sleep 2
      done
      if [ -z "$MYSQL_C" ] || ! docker exec "$MYSQL_C" mysqladmin ping -ppassword >/dev/null 2>&1; then
        echo "MySQL not ready after timeout"; docker compose logs mysql || true; exit 1
      fi
    - |
      # check redis
      REDIS_C=$(docker compose ps -q redis) || true
      if [ -z "$REDIS_C" ]; then echo "Redis container missing"; docker compose ps; exit 1; fi
      if ! docker exec "$REDIS_C" redis-cli ping >/dev/null 2>&1; then echo "Redis not responding"; docker compose logs redis; exit 1; fi
    - sleep 5
    - |
      # check web app reachable from inside container (wait loop, expect HTTP 200)
      OPENQDA_C=$(docker compose ps -q openqda) || true
      if [ -z "$OPENQDA_C" ]; then echo "OpenQDA container missing"; docker compose ps; exit 1; fi
      for i in $(seq 1 60); do
        HTTP=$(docker exec "$OPENQDA_C" sh -c 'curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8000/' ) || HTTP=""
        if [ "$HTTP" = "200" ]; then
          echo "Web app ready (HTTP 200)"; break
        fi
        echo "Waiting for web app... attempt=$i, got=$HTTP"
        sleep 3
      done
      HTTP=$(docker exec "$OPENQDA_C" sh -c 'curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8000/' ) || HTTP=""
      if [ "$HTTP" != "200" ]; then
        echo "Web app not responding (last HTTP=$HTTP)"; docker compose logs openqda -t --tail=200; exit 1
      fi
    - echo "All integration checks passed"
  when: on_success
  after_script:
    - docker compose down --volumes --remove-orphans
    - docker system prune -af || true
